# 进程同步与进程互斥

## 顺序程序与并发程序特征

### 顺序程序特征
- 顺序性
- 封闭性/运行环境的封闭性
- 确定性
- 可再现性

### 并发程序特征
- 并发性
- 共享性
- 随机性

## 进程互斥
- 由于各进程要求共享资源，而且有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系称为进程的互斥
- 系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源
- 在进程中涉及到互斥资源的程序段叫临界区

## 进程同步
- 进程同步是指多个进程需要相互配合共同完成一项任务

# 进程间通信目的
- 数据传输：一个进程需要将它的数据发送给另一个进程
- 资源共享：多个进程之间共享同样的资源
- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某个事件（如进程终止时要通知其父进程）
- 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它状态的改变


# 进程间通信发展
- 管道
- System V进程间通信
- POSIX进程间通信

# 进程间通信分类
- 文件
- 文件锁（互斥，读写锁）
- 管道（pipe）和有名管道（FIFO）
- 信号（signal）
- 消息队列
- 共享内存
- 信号量
- 互斥量
- 条件变量
- 读写锁
- 套接字（socket）
- System V IPC
    - System V消息队列
    - System V共享内存
    - System V信号量
- POSIX IPC
    - 消息队列
    - 共享内存
    - 信号量
    - 互斥量
    - 条件变量
    - 读写锁 

# 进程间共享信息的三种方式
![ipc](http://lx.hanyajun.com/IPC.png)

# IPC对象的持续性
- 随进程持续：一直存在直到打开的最后一个进程结束
- 随内核持续：一直存在直到内核自举或显式删除（如System V消息队列、共享内存、信号量）
- 随文件系统持续：一直存在直到显式删除，即使内核自举还存在（POSIX消息队列、共享内存、信号量如果是使用映射文件来实现）

# 死锁
死锁是指多个进程之间互相等待对方的资源，而在得到对方资源之前又不释放自己的资源，这样，造成循环等待的一种现象。如果所有进程都在等待一个不可能发生的事情，则进程死锁了。
## 死锁产生的必要条件
- 互斥条件
    - 进程对资源进行排他性使用，即在一段时间内某资源仅为一个进程所占用
- 请求和保持条件
    - 当进程因请求资源而阻塞时，对已获得的资源保持不放
- 不可剥夺条件
    - 进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时由自己释放
- 环路等待条件
    - 各个进程组成封闭的环形链，每个进程都等待下一个进程所占用的资源
    
## 防止死锁的办法
- 资源一次性分配：破坏请求和保持条件
- 可剥夺资源：破坏不可剥夺条件
- 资源有序分配法：破坏循环等待条件

## 死锁避免
- 预防死锁的几种策略，会严重地损害系统性能，因此在避免死锁时，要施加较弱的限制，从而获得较为满意的系统性能
- 由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中，最具有代表性的避免死锁算法是银行家算法。

# 信号量与PV原语
- 信号量和P、V原语由Dijkstra(迪杰斯特拉)提出
- 信号量
    - 互斥：P、V在同一个进程中
    - 同步：P、V在不同进程中
- 信号量值含义
    - S>0: S表示可用资源个数
    - S=0: 表示无可用资源，无等待进程
    - S<0: |S|表示等待队列中进程个数
    
# 消息队列
- 消息队列提供了一个从一个进程向另一个进程发送一块数据的方法
- 每个数据块都被认为有一个类型，接收者进程接收的数据块可以有 不同的类型值
- 消息队列也有管道一样的不足，就是每个消息的最大长度时有限的（MSGMAX），每个消息队列的总的字节数也是有上限的（MSGMNB），系统上消息队列的总数也有上限（MSGMNI）

![消息队列结构体](http://lx.hanyajun.com/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E4%BD%93.png)

# IPC对象数据结构
- 内核为每个IPC对象维护一个数据结构

![IPC结构体](http://lx.hanyajun.com/ipc%E7%BB%93%E6%9E%84.png)

# 消息队列函数
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

//创建或者访问一个消息队列
int msgget(key_t key, int msgflg);

/******************************************
参数：
    key:某个消息队列的名字
    msgflg:由九个权限标志构成，它们的用法和创建文件时使用mode模式标志是一样的
    
返回值：
    成功返回一个非负整数，即该消息队列的标识码，失败返回-1
*******************************************/


//控制消息队列
int msgctl(int msgid, int cmd, struct msgid_ds *buf);

/******************************************
参数：
    msgid:由msgget函数返回的消息队列标识码
    cmd:是将要采取的动作（有三个可取值）
    
返回值：
    成功返回0，失败返回-1
*******************************************/
```
![cmd三个取值](http://ww3.sinaimg.cn/large/006tNc79gy1g4dhaxdkipj31pw0k015i.jpg)

```c
//往消息队列中发送一条消息
int msgsnd(int msgid, const void *msgp,size_t msgsz, int msgflg);

/******************************************
参数：
    msgid:由msgget函数返回的消息队列标识码
    msgp:是一个指针，指向准备发送的消息
    msgsz:是msgp指向的消息长度，这个长度不含保存消息类型的那个long int长整型
        消息结构在两方面受制约，一方面，必须小于系统规定的上限；其次，必须以一个长整型开始，接收者函数将利用这个长整型确定消息的类型。
    msgflg:控制着当前消息队列满或达到系统上限时要做的处理
        = IPC_NOWAIT表示队列满不等待，返回EAGAIN错误，填0则队列满时已阻塞的方式等待
    
返回值：
    成功返回0，失败返回-1
*******************************************/


//从消息队列中接收一条消息
ssize_t msgrcv(int msgid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

/******************************************
参数：
    msgid:由msgget函数返回的消息队列标识码
    msgp:是一个指针，指向准备接收的消息
    msgsz:是msgp指向的消息长度，这个长度不含保存消息类型的那个long int长整型
    msgtyp:它可以实现接收优先级的简单形式
        =0:返回队列第一条消息
        >0:返回队列第一条类型等于msgtype的消息
        <0:返回队列第一条类型小于等于msgtype绝对值的消息
    msgflg:控制着队列中没有相应类型的消息可供接收时将要发生的事
        =IPC_NOWAIT:队列没有可读消息时不等待，返回ENOMSG错误
        =MSG_NOERROR:消息大小超过msgsz时被截断
        =MSG_EXCEPT(msgtype>0):接收类型不等于msgtype的第一条消息
    
返回值：
    成功返回实际放到接收缓冲区里去的字符个数，失败返回-1
*******************************************/

```