# select

>本程序中：
>
>select()同时可以检测stdio,sock两个描述符的可读事件
>
>这时对等方，任何时候发送数据过来都可以及时处理，而不会因为程序阻塞在了stdio而无法对套接口sock进行读操作，导致程序无法向前推进


- select()使得任何一个IO产生事件，都能及时的得到通知，得到通知之后都能进行及时的处理
- 处理多个IO程序时，又想用当进程时用select()比较方便
- 通常将用select()实现的服务器称为并发服务器。

# 读、写、异常事件发生条件

## 可读

- 套接口缓冲区中有数据可读；（对等方发送了数据过来，填充了套接口缓冲区）
- 连接的读一半关闭，即接收到FIN段，读操作将返回0；（对端调用close()方法，导致发送一个FIN段，也能通知select()表示有套接口产生了可读事件）
- 如果是监听套接字，已完成连接队列不为空时；(对等方在进行connect()操作，一旦连接完成，那么已连接队列中就产生了一个条目，此时监听套接口就会产生可读事件，通知select()检测到该事件)
- 套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来获取

## 可写

- 套接口发送缓冲区有空间容纳数据；（缓冲区未满，可以将数据写入到缓冲区当中，这时都将产生可写事件，所以一般不关心可写事件，大部分时候都会不断产生可写事件）
- 连接的写一半关闭，即接收到RST段之后，再次调用write操作；（当对等方调用close()关闭了套接口，并且进程已经销毁，这时对等方关闭了套接口仅仅意味着对等方不会发送数据过来了，不代表不能往对等方发送数据，若此时发送数据给对等方，会收到一个RST段通知我们对等方已关闭，连接已经重置，这时再调用write()，是允许的，也能被select()监测到，这时就会产生SIG_PIPE信号）
- 套接口上发生了一个错误待处理，错误可以通过getsockopt指定SO_ERROR选项来获取

## 异常

- 套接口存在带外数据


# select限制

>用select()实现的并发服务器，能达到的并发数，受两方面限制

- 一个进程能打开的最大文件描述符个数限制（这可以通过调整内核参数来改变）
```bash
$ulimit -n
1024
$sudo ulimit -n 2048    //修改个数限制
```

```c
// 程序获取最大文件描述符个数限制
struct rlimit rl;
if (getrlimit(RLIMIT_NOFILE, &rl) < 0)
    ERR_EXIT("getrlimit");
printf("%d\n", rl.rlim_max);

// 程序设置最大文件描述符个数（只是更改当前进程的最大文件描述符个数）
rl.rlim_cur = 2048;
rl.rlim_max = 2048;
if (setrlimit(RLIMIT_NOFILE, &rl) < 0)
    ERR_EXIT("setrlimit");
```

- select()中的fd_set集合容量的限制(FD_SETSIZE)（这需要重新编译内核）

FD_SETSIZE在头文件宏定义中定义为1024，修改只能修改宏定义，并重新编译内核